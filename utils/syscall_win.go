// Code generated by 'go generate'; DO NOT EDIT.
package utils

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

// IsErrSuccess checks if an "error" returned is actually the
// success code 0x0 "The operation completed successfully."
// https://github.com/JamesHovious/w32/blob/master/utils.go#L255
func IsErrSuccess(err error) bool {
	if errno, ok := err.(syscall.Errno); ok {
		if errno == 0 {
			return true
		}
	}
	return false
}

var (
	modadvapi32 = windows.NewLazySystemDLL("advapi32.dll")
	modkernel32 = windows.NewLazyDLL("kernel32.dll")

	procInitializeProcThreadAttributeList = modadvapi32.NewProc("InitializeProcThreadAttributeList")
	procCreateProcessA                    = modkernel32.NewProc("CreateProcessA")
	procCreateProcessW                    = modkernel32.NewProc("CreateProcessW")
	procCreateThread                      = modkernel32.NewProc("CreateThread")
	procGetExitCodeThread                 = modkernel32.NewProc("GetExitCodeThread")
	procQueueUserAPC                      = modkernel32.NewProc("QueueUserAPC")
	procResumeThread                      = modkernel32.NewProc("ResumeThread")
	procVirtualAllocEx                    = modkernel32.NewProc("VirtualAllocEx")
	procVirtualProtectEx                  = modkernel32.NewProc("VirtualProtectEx")
	procWriteProcessMemory                = modkernel32.NewProc("WriteProcessMemory")
)

func InitializeProcThreadAttributeList(lpAttributeList *PROC_THREAD_ATTRIBUTE_LIST, dwAttributeCount uint32, dwFlags uint32, lpSize *uint64) (err error) {
	r1, _, e1 := syscall.Syscall6(procInitializeProcThreadAttributeList.Addr(), 4, uintptr(unsafe.Pointer(lpAttributeList)), uintptr(dwAttributeCount), uintptr(dwFlags), uintptr(unsafe.Pointer(lpSize)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CreateProcessA(lpApplicationName *byte, lpCommandLine *byte, lpProcessAttributes *windows.SecurityAttributes, lpThreadAttributes *windows.SecurityAttributes, bInheritHandles bool, dwCreationFlags uint32, lpEnvironment unsafe.Pointer, lpCurrentDirectory *byte, startupInfo *StartupInfoEx, lpProcessInformation *windows.ProcessInformation) (err error) {
	var _p0 uint32
	if bInheritHandles {
		_p0 = 1
	}
	r1, _, e1 := syscall.Syscall12(procCreateProcessA.Addr(), 10, uintptr(unsafe.Pointer(lpApplicationName)), uintptr(unsafe.Pointer(lpCommandLine)), uintptr(unsafe.Pointer(lpProcessAttributes)), uintptr(unsafe.Pointer(lpThreadAttributes)), uintptr(_p0), uintptr(dwCreationFlags), uintptr(lpEnvironment), uintptr(unsafe.Pointer(lpCurrentDirectory)), uintptr(unsafe.Pointer(startupInfo)), uintptr(unsafe.Pointer(lpProcessInformation)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CreateProcessW(lpApplicationName string, lpCommandLine string, lpProcessAttributes *SECURITY_ATTRIBUTES, lpThreadAttributes *SECURITY_ATTRIBUTES, bInheritHandles BOOL, dwCreationFlags uint32, lpEnvironment unsafe.Pointer, lpCurrentDirectory string, lpStartupInfo *STARTUPINFOW, lpProcessInformation *PROCESS_INFORMATION) (e error) {
	var _p0,_p1,_p2 *uint16
	if len(lpApplicationName) > 0 {_p0, e = syscall.UTF16PtrFromString(lpApplicationName)}
	if e != nil {
		return
	}
	if len(lpCommandLine) > 0 {_p1, e = syscall.UTF16PtrFromString(lpCommandLine)}
	if e != nil {
		return
	}
	if len(lpCurrentDirectory) > 0 {_p2, e = syscall.UTF16PtrFromString(lpCurrentDirectory)}
	if e != nil {
		return
	}
	ret, _, lastErr := procCreateProcessW.Call(
		uintptr(unsafe.Pointer(_p0)),
		uintptr(unsafe.Pointer(_p1)),
		uintptr(unsafe.Pointer(lpProcessAttributes)),
		uintptr(unsafe.Pointer(lpProcessInformation)),
		uintptr(bInheritHandles),
		uintptr(dwCreationFlags),
		uintptr(lpEnvironment),
		uintptr(unsafe.Pointer(_p2)),
		uintptr(unsafe.Pointer(lpStartupInfo)),
		uintptr(unsafe.Pointer(lpProcessInformation)),
	)
	if ret == 0 {
		e = lastErr
	}
	return
}

func CreateThread(lpThreadAttributes *windows.SecurityAttributes, dwStackSize uint32, lpStartAddress uintptr, lpParameter uintptr, dwCreationFlags uint32, lpThreadId *uint32) (threadHandle windows.Handle, err error) {
	r0, _, e1 := syscall.Syscall6(procCreateThread.Addr(), 6, uintptr(unsafe.Pointer(lpThreadAttributes)), uintptr(dwStackSize), uintptr(lpStartAddress), uintptr(lpParameter), uintptr(dwCreationFlags), uintptr(unsafe.Pointer(lpThreadId)))
	threadHandle = windows.Handle(r0)
	if threadHandle == 0 {
		err = errnoErr(e1)
	}
	return
}

func GetExitCodeThread(hTread windows.Handle, lpExitCode *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procGetExitCodeThread.Addr(), 2, uintptr(hTread), uintptr(unsafe.Pointer(lpExitCode)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func QueueUserAPC(pfnAPC uintptr, hThread windows.Handle, dwData uintptr) (err error) {
	r1, _, e1 := syscall.Syscall(procQueueUserAPC.Addr(), 3, uintptr(pfnAPC), uintptr(hThread), uintptr(dwData))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func ResumeThread(hTread windows.Handle) {
	syscall.Syscall(procResumeThread.Addr(), 1, uintptr(hTread), 0, 0)
	return
}

//func VirtualAllocEx(hProcess HANDLE, lpAddress int, dwSize int, flAllocationType int, flProtect int) (addr uintptr, err error) {
//	ret, _, err := procVirtualAllocEx.Call(
//		uintptr(hProcess),  // The handle to a process.
//		uintptr(lpAddress), // The pointer that specifies a desired starting address for the region of pages that you want to allocate.
//		uintptr(dwSize),    // The size of the region of memory to allocate, in bytes.
//		uintptr(flAllocationType),
//		uintptr(flProtect))
//	if int(ret) == 0 {
//		return ret, err
//	}
//	return ret, nil
//}

func VirtualAllocEx(hProcess windows.Handle, lpAddress uintptr, dwSize uintptr, flAllocationType uint32, flProtect uint32) (addr uintptr, err error) {
	r0, _, e1 := syscall.Syscall6(procVirtualAllocEx.Addr(), 5, uintptr(hProcess), uintptr(lpAddress), uintptr(dwSize), uintptr(flAllocationType), uintptr(flProtect), 0)
	addr = uintptr(r0)
	if addr == 0 {
		err = errnoErr(e1)
	}
	return
}

func VirtualProtectEx(hProcess windows.Handle, lpAddress uintptr, dwSize uintptr, flNewProtect uint32, lpflOldProtect *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procVirtualProtectEx.Addr(), 5, uintptr(hProcess), uintptr(lpAddress), uintptr(dwSize), uintptr(flNewProtect), uintptr(unsafe.Pointer(lpflOldProtect)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

//func WriteProcessMemory(hProcess HANDLE, lpBaseAddress uint32, data []byte, size uint) (err error) {
//	var numBytesRead uintptr
//
//	_, _, err = procWriteProcessMemory.Call(uintptr(hProcess),
//		uintptr(lpBaseAddress),
//		uintptr(unsafe.Pointer(&data[0])),
//		uintptr(size),
//		uintptr(unsafe.Pointer(&numBytesRead)))
//	if !IsErrSuccess(err) {
//		return
//	}
//	err = nil
//	return
//}


func WriteProcessMemory(hProcess windows.Handle, lpBaseAddress uintptr, lpBuffer *byte, nSize uintptr, lpNumberOfBytesWritten *uintptr) (err error) {
	r1, _, e1 := syscall.Syscall6(procWriteProcessMemory.Addr(), 5, uintptr(hProcess), uintptr(lpBaseAddress), uintptr(unsafe.Pointer(lpBuffer)), uintptr(nSize), uintptr(unsafe.Pointer(lpNumberOfBytesWritten)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}
